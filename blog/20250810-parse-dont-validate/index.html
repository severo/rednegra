
<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/prism.css">
  <title>Parse, don't validate</title>
  <link href="https://huggingface.co/severo" rel="me">
  <link href="https://observablehq.com/@severo" rel="me">
  <link href="https://github.com/severo" rel="me">
  <link href="https://mastodon.social/@severo" rel="me">
  <link href="https://bsky.app/profile/severo-dev.bsky.social" rel="me">
  <link href="https://www.linkedin.com/in/sylvain--lesage/" rel="me">
  <link href="https://www.researchgate.net/profile/Sylvain_Lesage" rel="me">
  <link href="https://mamot.fr/@severo_bo" rel="me">
  <link href="https://seenthis.net/people/severo" rel="me">
</head>
<body>
  <main>
    <header>
      <h1>Parse, don't validate</h1>
      <p class="date">Published on: 2025-08-10</p>
    </header>
    <div><p>Alexis King coined the expression <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">&quot;Parse, don't validate&quot;</a> in 2019.</p>
<p>I discovered it today reading <a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-12/">Speeding up the JavaScript ecosystem - Semver</a> by Marvin Hagemeister.</p>
<blockquote>
<p>To validate input correctness, both validator functions parse the input data, allocate the resulting data structure and return back the original input string if it passed the check. When we call the satisfies function, we do the same work that we just threw away again. This is a classic case of doing twice the work necessary due to not following the &quot;Parse, don't validate&quot; rule.</p>
</blockquote>
<p>Quoting Alexis King, the principle is to use the typing system to:</p>
<ul>
<li>Use a data structure that makes illegal states unrepresentable,</li>
<li>Push the burden of proof upward as far as possible, but no further.</li>
</ul>
<p>I think the most useful insight is the first point: <em>using a data structure that makes illegal states unrepresentable</em> and its comment:</p>
<blockquote>
<p>Model your data using the most precise data structure you reasonably can. If ruling out a particular possibility is too hard using the encoding you are currently using, consider alternate encodings that can express the property you care about more easily. Donâ€™t be afraid to refactor.</p>
</blockquote>
<p>The second point is a direct consequence of the first.</p>
<p>His example uses Haskell and treats the problem of an array that should not be empty. Instead of passing a regular array along all the code, he creates a &quot;non empty array&quot; type, and parses his array as soon as possible, returning a &quot;non empty array&quot;, or failing. It's known as <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">&quot;type narrowing&quot;</a> (or type guarding) in TypeScript.</p>
<h2>Translated in TypeScript</h2>
<p>Let's reproduce the example in TypeScript. We want to parse a regular array and ensure it's not empty.</p>
<p>We define type as:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">NonEmptyArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>(thanks Copilot for helping me with that, as generic types are not my favorite hobby)</p>
<p>Then, the parsing function is:</p>
<pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">parseArray</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> NonEmptyArray<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Input is not an array"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Array is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> input <span class="token keyword">as</span> NonEmptyArray<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Once the array has been parsed, you will never have to check its emptiness again. If you modify the array with <code>.map</code>, TypeScript will ensure you still have a non-empty array as a result.</p>
</div>
  </main>
</body>

